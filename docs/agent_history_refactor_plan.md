# План рефакторинга истории агента

## Текущее состояние и проблемы
- `AgentRunPayload.to_dict()` раздувает `raw_result`: дублирует поля последнего инструмента и переносит их в корень (`tool_name`, `tool_call_id`, `call_id`, `tool_arguments`, `tool_result`, `error`), из-за чего один и тот же блок данных фигурирует в нескольких местах с разными именами и статусами. Код: `app/agent/run_contract.py` строки 379–655.
- `_AgentRunRecorder` параллельно накапливает однотипные данные в `_llm_trace`, `_llm_steps`, `_llm_requests`, `_snapshots` и `_order`, а затем смешивает их в `diagnostic.tool_results`, теряя хронологию событий и создавая повторения. Код: `app/agent/local_agent.py` строки 182–414.
- Построение UI-таймлайна (`_build_agent_turn`) восстанавливает хронологию по эвристикам из `raw_result`, `diagnostic`, `tool_results` и `llm_steps`, дополняя отсутствующие времена и запросы «на глазок». Это приводит к несостыкованности между отображаемой перепиской и техническим логом. Код: `app/ui/agent_chat_panel/view_model.py` строки 326–430.

## Цели рефакторинга
- Хранить историю агента в одном каноническом формате без дублирования и с явным порядком событий (LLM-ответы, reasoning, вызовы инструментов, системные сообщения) с точными метками времени.
- Делать технический лог прямой сериализацией внутренней истории без дополнительных преобразований, чтобы совпадали события, порядок и поля с «перепиской».
- Упростить построение UI-таймлайна: отображение должно опираться на готовую линейную ленту событий, а не на эвристические реконструкции.

## План работ
1. **Определить новый контракт истории.**
   - В `app/agent/run_contract.py` ввести каноническую структуру событий (например, `AgentEvent` с типами `llm_step`, `tool_event`, `system_note`) и компактный `AgentRunLog`, убрав корневые дубликаты (`last_tool`, зеркальные поля инструмента, отдельные списки `llm_steps`/`llm_requests`).
   - Обозначить обязательные метки времени и идентификаторы, определить единый порядок сортировки (по времени с детерминированным tiebreaker).
2. **Переписать `_AgentRunRecorder` на новый контракт.**
   - В `app/agent/local_agent.py` заменить параллельные структуры (`_llm_trace`, `_llm_steps`, `_llm_requests`, `_order`) на единый поток событий, фиксирующий, когда сформирован запрос к LLM, получен промежуточный ответ, начат/завершён инструмент, возникла ошибка и т.д.
   - Обеспечить однократное представление снимков инструментов (без `last_tool` в корне) и консистентные статусы (`ok/status` только в одном месте).
3. **Адаптировать сохранение `ChatEntry`.**
   - В `app/ui/chat_entry.py` и `app/ui/agent_chat_panel/history_utils.py` пересмотреть сериализацию/десериализацию `raw_result` и `tool_results`: хранить новый `AgentRunLog`, убрать сохранение лишних производных полей (`tool_messages`, дублирующие `tool_results`, неиспользуемые `diagnostic` фрагменты).
   - Продумать миграцию или жёсткий сброс устаревших полей (обратная совместимость не требуется по требованиям).
4. **Упростить построение UI-таймлайна.**
   - В `app/ui/agent_chat_panel/view_model.py` переписать `_build_agent_turn` и связанные функции, чтобы они читали уже отсортированный список событий и не восстанавливали данные «по догадке» из разных источников.
   - Обеспечить, чтобы отображаемые reasoning и карточки инструментов брались из единственного источника событий, а технический лог мог выводиться как есть.
5. **Унифицировать технический лог.**
   - В слоях, которые формируют артефакт «Скопировать технический лог» (UI-компоненты и тесты `tests/gui/test_agent_chat_panel.py`), переключиться на новый `AgentRunLog` без переработки данных: лог должен быть детерминированным и отсортированным.
   - Убедиться, что копия переписки использует те же события (без ручного склеивания reasoning и финального ответа).
6. **Покрыть переход тестами.**
   - Добавить целевые тесты на порядок событий и отсутствие дубликатов в `tests/gui/test_agent_chat_panel.py` и, при необходимости, на уровне unit-тестов для `AgentRunLog`.
   - Обновить существующие снепшоты/фикстуры под новый формат, удаляя устаревшие поля.

## Прогресс
- [~] Шаг 1: введены `AgentEvent` и `AgentEventLog`, `AgentRunPayload` сохраняет линейный журнал событий и строит `diagnostic.event_log` из него без дублирующих корневых полей.
- [~] Шаг 2: `_AgentRunRecorder` переписан на поток событий, убраны вспомогательные `_llm_steps`/`_llm_requests` и порядок инструментов строится по событиям.
- [+] Шаг 3: адаптированы UI-компоненты — таймлайн агента и лог-экспорт строятся поверх `AgentEvent` без перебора устаревших полей.
- [+] Шаг 4: сериализация `ChatEntry` строит `tool_messages` детерминированно из `AgentRunPayload.tool_results` и не сохраняет отдельные снимки, очищая дублирующие поля в `raw_result`/`diagnostic` при загрузке и записи.
- [>] Шаг 5–6: продолжаем обновлять UI-тесты/снепшоты под событийную модель и чистить экспорт истории. Сортировка снимков инструментов теперь каноническая (по временным меткам) и попадает в `raw_result`/лог без перестановок, временная метка хода подтягивается до последнего события инструмента. Остаётся добить остальные сценарии GUI-таймлайна и сверить экспорт логов с финальной хронологией.

## Дополнительные замечания
- При рефакторинге убрать легаси, не тащить совместимость со старыми полями и промежуточными форматами. При необходимости — один раз конвертировать старые записи в миграционном шаге хранилища.
- Проверить влияние на экспорт/импорт истории (SQLite через `HistoryStore`) и обновить приём/вывод данных, чтобы база содержала только новую структуру без дублирующих колонок.
