# План рефакторинга agent chat timeline

## Контекст и симптомы
- Нынешняя сборка таймлайна чата использует несколько источников сразу: `AgentRunPayload.timeline`, `AgentEventLog`, снапшоты инструментов и LLM trace. Если `timeline` частично заполнен или отсутствует, `_resolve_agent_timeline` пытается достраивать последовательность заново, а `_build_agent_events` возвращает пустой список событий при отсутствии таймлайна. В результате карточка хода может содержать только блоки reasoning и вызовы инструментов без самих ответов ассистента или с нарушенным порядком.【F:app/ui/agent_chat_panel/view_model.py†L486-L596】【F:app/ui/agent_chat_panel/components/segments.py†L623-L706】
- Отрисовка сообщений ассистента полностью зависит от того, попадёт ли в таймлайн событие `llm_step` или `agent_finished`. При пропуске этих событий финальный ответ не рендерится, даже если текст ответа и reasoning сохранены в `ChatEntry`. Сами вызовы инструментов при этом продолжают отображаться, создавая впечатление инверсии порядка сообщений.【F:app/ui/agent_chat_panel/view_model.py†L1125-L1196】【F:app/ui/agent_chat_panel/components/segments.py†L641-L706】
- Канонизация таймлайна выполняется в нескольких местах (например, внутри `LocalAgent.to_payload()` и в панели при финализации запроса), что затрудняет контроль за инвариантами и приводит к расхождениям между сохранёнными в истории данными и тем, что использует view-model.【F:app/agent/local_agent.py†L424-L491】【F:app/ui/agent_chat_panel/panel.py†L1607-L1847】

## Текущий поток данных и точки расхождений
- **Сбор данных на рантайме.** `LocalAgent` добавляет события `agent_finished`, конвертирует event log в trace и строит `timeline_debug`/`canonical_timeline` перед возвратом `AgentRunPayload`, но при этом включает в payload как канонический таймлайн, так и исходный event log, что создаёт два конкурирующих источника истины.【F:app/agent/local_agent.py†L362-L491】
- **Нормализация на уровне панели.** В `_finalize_prompt` и `_process_result` панель повторно мерджит снапшоты инструментов, синтезирует payload через `ensure_canonical_agent_payload`, а затем сериализует в историю. Это приводит к дублированию «канонизации» и возможной повторной сборке таймлайна уже после сохранения результата.【F:app/ui/agent_chat_panel/panel.py†L1607-L1847】
- **Реконструкция во view-model.** `_resolve_agent_timeline` пытается построить таймлайн заново из `event_log` при любом подозрении на неполноту и кэширует новый набор событий. Итоговый порядок зависит от того, кто победил: `payload.timeline` или пересобранная версия, что объясняет инверсии и пропуски в UI.【F:app/ui/agent_chat_panel/view_model.py†L486-L596】

### Обнаруженные структурные проблемы
1. **Смешение обязанностей канонизации и отображения.** Логика «починки» таймлайна размазана между рантаймом (формирование payload), панелью (мердж снапшотов и уплотнение timeline) и view-model (реконструкция при чтении истории). Из-за этого нет единого инварианта сохранённого `ChatEntry`, и каждый слой вправе по‑своему переставить события.
2. **Нестабильные ключи идентификации шагов.** В `event_log` и timeline одновременно используются `sequence`, `step_index` и `call_id`; отсутствует проверка уникальности `call_id`, а `sequence` может восстанавливаться постфактум. Это усложняет детерминированный порядок при ререндере и при дедупликации кэша в `_agent_timeline_fingerprint_for_entry`.【F:app/ui/agent_chat_panel/view_model.py†L507-L623】
3. **Неявная деградация при отсутствии канонических данных.** Если payload не содержит таймлайна или он признан «неполным», UI просто возвращает пустой список событий; при этом текст ответа и reasoning могут быть в истории, но не будут отображены. Это приводит к «пустым» карточкам с одним reasoning и набором вызовов инструментов без финального ответа.

## Архитектурные причины перестановок
1. **Раздвоенный источник истины для порядка событий.** View-model пытается склеить `event_log`, снапшоты инструментов и LLM trace на лету, даже если в `AgentRunPayload` уже лежит какой-то таймлайн. При частичных данных или несовпадении полей шаги ответа могут быть отброшены как «неполный таймлайн» и не попадать в итоговые `AgentTimelineEvent`.
2. **Отсутствие гарантий полноты при чтении истории.** Исторические записи (`ChatEntry`) хранят `raw_result` без жёстких инвариантов: если сохранённый `timeline` дырявый или несогласованный с trace/snapshots, при ререндере карточки финальный ответ не выводится и порядок событий воспроизводится по текущим эвристикам, а не по исходному запуску.
3. **Связывание UI-рендеринга с наличием таймлайн-событий.** `_build_agent_events` не строит событийную ленту, если нет канонического списка, хотя текст финального ответа и reasoning доступны. Это делает UI чувствительным к любым сбоям в канонизации и порождает «пустые» карточки с одними инструментами.

## План рефакторинга
1. **Выделить единый этап канонизации таймлайна.**
   - Вынести сборку `AgentTimelineEntry` в отдельный сервис/утилиту (в `app/agent/timeline_canon.py` или аналогичном модуле), вызываемый строго один раз при финализации `AgentRunPayload` до записи в историю. В историю и кэш кладём только канонизированный вариант.
   - Оставить в `AgentRunPayload` один источник порядка (`timeline`) и хранить event log только для диагностики; удалить повторную реконструкцию во view-model и в панели, заменив её валидацией и логированием отклонений.
   - Стандартизировать идентификаторы: `sequence` строго инкрементный без дыр, `call_id` уникальный и обязательный для tool-событий, `step_index` синхронизирован с trace. Отдельный валидатор должен падать/помечать запись, если инварианты нарушены.
2. **Ужесточить инварианты сохранённого `ChatEntry`.**
   - При загрузке истории проверять целостность `timeline` и расхождение с `event_log`/trace; если нет `agent_finished` или отсутствуют `llm_step`, маркировать запись как «повреждённую» и рендерить fallback: reasoning + финальный текст из `result_text` без попыток переупорядочивания.
   - Перед записью в SQLite нормализовать схему хранения (стабильные `sequence`/`call_id`, сортировка событий, сжатие null‑полей), добавив checksum/etag таймлайна для последующей дедупликации и миграций.
3. **Упростить построение событий в UI.**
   - `_build_agent_events` принимает только канонический таймлайн и строит fallback события из `AgentTurn`, если запись помечена как повреждённая (без попыток угадать порядок из `diagnostic`).
   - Рендеринг фиксирует порядок `llm_step → tool_call → agent_finished` по `sequence`, а `SegmentListView` сравнивает события по `(sequence, call_id, kind)` без доп. эвристик.
4. **Развести кэширование и источники данных.**
   - `ConversationTimelineCache` и `_agent_timeline_fingerprint_for_entry` используют checksum канонического таймлайна, а не комбинацию источников. При любом несоответствии checksum кэш сбрасывается и запись прогоняется через валидатор.
   - Панель перестаёт мерджить снапшоты постфактум: `ensure_canonical_agent_payload` возвращает уже канонизированный payload, а `tool_messages` и `diagnostic` хранятся как побочный материал, не влияющий на порядок.
5. **Усилить тестовое покрытие порядка событий.**
   - Интеграционные тесты на чтение истории: сохраняем записи с дырявым `event_log`/`timeline`, запускаем ререндер карточки и проверяем, что UI показывает финальный ответ и последовательность без инверсий.
   - GUI-smoke сценарий для длинного диалога с несколькими итерациями LLM+tools: проверка порядка пузырей (reasoning → ответ → инструменты) и стабильного числа событий при повторном открытии истории.
   - Юнит‑пакет на валидатор: входные комбинации `event_log`/trace/`timeline` с пропусками/дубликатами → ожидаемые статусы (`valid`, `damaged`, `repaired`).
6. **Диагностика и миграция.**
   - Логирование нарушений инвариантов с привязкой к `conversation_id` и `entry_id`, экспорт проблемных записей в отдельный дамп для ручной проверки.
   - Миграция истории: один проход по существующим записям, канонизация таймлайна сервисом, пометка `repaired_by=version` и добавление отчёта о числе исправленных/повреждённых записей.

## Что делать в первую очередь
1. **Создать канонизатор таймлайна как отдельный модуль** и переподключить `LocalAgent.to_payload()` и `ensure_canonical_agent_payload` к нему; удалить двойную сборку в панели и view-model.
2. **Добавить валидацию/etag в `ChatEntry`**: при загрузке истории вычислять checksum таймлайна и состояние целостности; включить это в кеш‑ключи.
3. **Упростить `_resolve_agent_timeline`**: оставить только чтение готового таймлайна и fallback на «повреждённую» карточку без реконструкции.
4. **Расширить тесты**: интеграция на загрузку старых записей, GUI smoke на порядок пузырей, юниты на валидатор и checksum.

## Риски и ожидаемый эффект
- Жёсткая привязка UI к каноническому таймлайну потребует обновить все места формирования `raw_result`; потребуется аудит тестовых фикстур, которые до сих пор полагаются на эвристические реконструкции.
- Возможен всплеск перерисовок при смене схемы кеширования, если подписи событий станут вычисляться иначе; потребуется профилирование `SegmentListView` на длинных диалогах.
- После рефакторинга порядок сообщений должен определяться единственным источником (канонический таймлайн), без перестановок и пропуска ответов ассистента даже при частичных логах.

## Прогресс
- ✅ **Единый etag канонического таймлайна для UI-кеша.** Добавлен утилитарный модуль `app/agent/timeline_utils.py` с детерминированным `timeline_checksum`, а view-model теперь использует только checksum готового `payload.timeline` в `_agent_timeline_fingerprint` вместо смешивания event log, снапшотов и llm trace. Это фиксирует источник порядка для кеша и убирает влияние диагностических источников, если канонический таймлайн присутствует.
- ✅ **Быстрый сигнал деградации порядка.** Юнит‑тест `test_timeline_checksum_is_order_sensitive_and_stable` покрывает стабильность checksum при одинаковом наборе событий и её чувствительность к перестановкам, чтобы защитить вычисление etag от регрессий.
- ✅ **Checksum входит в payload и историю.** `LocalAgent` и `ensure_canonical_agent_payload` вычисляют `timeline_checksum` в момент финализации, сохраняют его в `AgentRunPayload` и сериализацию истории, а парсинг payload восстанавливает checksum даже если исходные данные его не содержали. Фингерпринт view-model теперь использует сохранённый checksum без пересчёта.
- ✅ **Целостность таймлайна отражается в `ChatEntry` и UI.** `ChatEntry` вычисляет состояние таймлайна (valid/missing/damaged) и checksum через `assess_timeline_integrity`, а fingerprint view-model опирается только на эти данные без реконструкции по event log. `_resolve_agent_timeline` больше не пересобирает порядок из диагностик, помечает повреждённые записи и передаёт статус в рендер.
- ✅ **Fallback-таймлайн для повреждённых записей.** `_build_agent_events` строит стабильный порядок пузырей даже при отсутствии канонического таймлайна, чтобы reasoning и финальный ответ агента не исчезали из UI.
- ✅ **Миграция состояния таймлайна при загрузке истории.** `ChatEntry` сериализует и восстанавливает `timeline_status`/`timeline_checksum`, а `HistoryStore.load_entries` перезаписывает старые записи с пропущенными метаданными и удаляет дублирующие `diagnostic.event_log` из `raw_result`, чтобы кеши и UI получали валидированное состояние без эвристик.
- ✅ **Кеши панели опираются на состояние таймлайна.** Fingerprint view-model больше не учитывает диагностический event log, полагаясь на checksum целостного таймлайна, статус интегрити и фактические снапшоты инструментов. Диагностические блоки, собираемые панелью, перестали подтягивать старые event log/LLM steps из прошлых записей, фиксируя сохранённое состояние без мерджа поверх канона.
- ✅ **Юнит-тесты таймлайна приведены к лаконичным сценариям.** Удалены дублирующие проверки реконструкции по event log и переписаны тесты кеша `ConversationTimelineCache` под новую канонизацию: теперь они фиксируют зависимость кеша от checksum канонического таймлайна и стабильность при изменении только диагностических данных.
- ⏳ **Следующий шаг:** укрепить GUI/интеграционные проверки порядка пузырей (smoke и unit) на длинных диалогах с несколькими итерациями LLM+tools, используя сохранённый `timeline_status`/`timeline_checksum` вместо реконструкций.
