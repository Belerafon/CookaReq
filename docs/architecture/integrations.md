# Интеграции и внешние взаимодействия CookaReq

> Черновой каркас: фиксирует структуру раздела и список аспектов, которые нужно осветить.

## 1. LLM и OpenRouter

### Конфигурация по умолчанию
- `app.settings.LLMSettings` наследует значения из `app.llm.constants`: базовый URL `https://openrouter.ai/api/v1` и модель `meta-llama/llama-3.3-70b-instruct:free`. Эта связка показала наименьшую вариативность в инструментальных ответах и используется GUI/CLI по умолчанию.
- Для тестов с reasoning-сегментами выбрана бесплатная модель `x-ai/grok-4-fast:free`, поскольку она поддерживает параметры `include_reasoning` и `reasoning` без дополнительной тарификации. Переопределить модель можно переменной окружения `OPENROUTER_REASONING_MODEL`, что упрощает эксплуатационные переключения.

### Настройка и секреты
- Ключ OpenRouter ищется в `.env` (переменная `OPEN_ROUTER`) и прокидывается в тесты через `tests.env_utils.load_secret_from_env`.
- GUI и CLI позволяют переопределить модель, URL и формат сообщений в пользовательских настройках (`settings.json`), которые валидируются Pydantic-схемами.

### Ограничения и fallback
- Без ключа или при отключённых реальных тестах (`COOKAREQ_RUN_REAL_LLM_TESTS` не установлен) сценарии в `tests/integration/test_llm_openrouter_integration.py` пропускаются, чтобы не генерировать ошибочные обращения.
- Ошибки валидации инструментов мапятся через `app.mcp.utils.exception_to_mcp_error` в финальный ответ агента, что предотвращает бесконечные повторы при некорректных tool calls.

### LLM client
- `LLMClient` остаётся тонким фасадом, который выбирает стратегию (chat/harmony/stream) и делегирует подготовку запросов и разбор ответов специализированным компонентам.
- `LLMRequestBuilder` отвечает за подготовку payload: нормализует историю, режет её по лимиту токенов, собирает системные блоки и преобразует формат сообщений (например, в Qwen-сегменты). Отдельный метод строит Harmony prompt на основе того же пайплайна.
- `LLMResponseParser` принимает сырой ответ от бэкенда, нормализует tool calls, восстанавливает JSON аргументов, собирает reasoning-сегменты и конвертирует их в `LLMReasoningSegment`/`LLMToolCall`. Логика восстановления и телеметрия по аргументам теперь сосредоточены здесь.
- Модуль `app.llm.logging` предоставляет `log_request`/`log_response`, чтобы фасад просто прокидывал полезную нагрузку, а детали телеметрии хранились в одном месте.
- Для юнит-тестов добавлены заглушки `tests/unit/llm/factories.py`: они позволяют подменить `LLMRequestBuilder`/`LLMResponseParser` и собрать синтетический `LLMResponse`, когда важно протестировать потребителей LLM без реальных сетевых обращений.

## 2. MCP-сервер и инструменты
- [ ] Архитектура MCP-сервера (FastAPI, IPC, запуск из GUI/CLI).
- [ ] Таблица зарегистрированных инструментов и их контрактов.
- [ ] Процедура добавления новых инструментов и тестирования.

### `get_requirement`

- Инструмент принимает `rid` строкой или массивом строк. Агент при обогащении
  контекста (см. `LocalAgent._fetch_requirement_summaries_async`) передаёт
  массив, сохраняя порядок RID из системного сообщения и удаляя дубликаты.
- Параметр `fields` используется для ограничения ответа двумя ключевыми
  полями (`title`, `statement`), чтобы сократить полезную нагрузку при
  асинхронных запросах контекста.
- Ответ всегда включает `result.items` с объектами `{rid, ...}` и опциональный
  список `missing`. Агент игнорирует пропущенные RID и не прерывает работу,
  если инструмент возвращает пустой список.

## 3. Взаимодействие с файловой системой и ОС
- [ ] Работа с файловыми диалогами, разрешениями, путями.
- [ ] Требования к окружению (wxPython, Python 3.12, зависимости).
- [ ] Особенности кроссплатформенности и различий между ОС.

## 4. Интеграция с другими сервисами
- [ ] Проверить наличие сторонних API (например, экспорты, уведомления).
- [ ] Зафиксировать потенциальные интеграции и ограничения.
- [ ] Сформулировать TODO для дальнейшего исследования.

## 5. Диаграммы и последовательности
- [ ] Определить ключевые сценарии для диаграмм последовательностей.
- [ ] Зафиксировать, какие инструменты использовать для визуализации.
- [ ] Прописать, где хранить исходники диаграмм и как их обновлять.

> После заполнения проверить согласованность с `components.md` и `data_and_config.md`.
